<b> Which type cast preserves the mathematical value in all cases?</b><br><ul><li>i64 as i32</li><li>usize as u64</li><li>i32 as i64</li><li>f64 as f32</li></ul>,i32 as i64
"<b> What do the vertical bars represent here?</b><br><br>```rust<br>str::thread::spawn(|| {<br>println!(""LinkedIn"");<br>});<br>```<br><br><ul><li>a closure</li><li>a thread</li><li>a future</li><li>a block</li></ul>",a closure<br><br>[reference](https://doc.rust-lang.org/book/ch13-01-closures.html#refactoring-with-closures-to-store-code)<br>
<b> Which choice is not a scalar data type?</b><br><ul><li>integer</li><li>float</li><li>boolean</li><li>tuple</li></ul>,tuple
<b> **\_** cannot be destructured.</b><br><ul><li>Traits</li><li>Tuples</li><li>Enums</li><li>Structs</li></ul>,Traits<br><br>[reference](https://rust-lang.github.io/rfcs/2909-destructuring-assignment.html)<br>
<b> Which `cargo` command checks a program for error without creating a binary executable?</b><br><ul><li>cargo --version</li><li>cargo init</li><li>cargo build</li><li>cargo check</li></ul>,cargo check
"<b> The term _box_ and related phrases such as _boxing a value_ are often used when relating to memory layout. What does _box_ refer to?</b><br><ul><li>It's creating a pointer on the heap that points to a value on the stack.</li><li>It's creating a pointer on the stack that points to a value on the heap.</li><li>It's creating a memory guard around values to prevent illegal access.</li><li>It's an abstraction that refers to ownership. ""Boxed"" values are clearly labelled.</li></ul>",It's creating a pointer on the stack that points to a value on the heap.
"<b> What is an alternative way of writing `slice` that produces the same result?</b><br><br>```rust<br>...<br>let s = String::form(""hello"");<br>let slice = &s[0..2];<br>```<br><br><ul><li>let slice = &s[len + 2];</li><li>let slice = &s[len - 2];</li><li>let slice = &s.copy(0..2);</li><li>let slice = &s[..2];</li></ul>",let slice = &s[..2];
<b> Using the `?` operator at the end of an expression is equivalent to **\_**.</b><br><ul><li>a match pattern that branches into True or False</li><li>calling ok_error()</li><li>calling panic!()</li><li>a match pattern that may result an early return</li></ul>,a match pattern that may result an early return
<b> Which is valid syntax for defining an array of i</b><br><ul><li>Array<i32>::with_capacity(10)</li><li>[i32]</li><li>Array<i32>::new(10)</li><li>[i32; 10]</li></ul>,[i32; 10]
"<b> What syntax is required to take a mutable reference to T, when used within a function argument?</b><br><br>```rust<br>fn increment(i: T) {<br>// body elided<br>}<br>```<br><br><ul><li>\*mut T</li><li>mut ref T</li><li>mut &T</li><li>&mut T</li></ul>",&mut T
<b> The smart pointers Rc and Arc provide reference counting. What is the API for incrementing a reference count?</b><br><ul><li>.add()</li><li>.incr()</li><li>.clone()</li><li>.increment()</li></ul>,.clone()<br><br>[reference](https://doc.rust-lang.org/book/ch15-04-rc.html)<br>
"<b> What happens when an error occurs that is being handled by the question mark (?) operator?</b><br><ul><li>The error is reported and execution continues.</li><li>An exception is raised. The effect(s) of the exception are defined by the error! macro.</li><li>The program panics immediately.</li><li>Rust attempts to convert the error to the local function's error type and return it as Result::Err. If that fails, the program panics.</li></ul>","Rust attempts to convert the error to the local function's error type and return it as Result::Err. If that fails, the program panics."
<b> Which comment syntax is not legal?</b><br><ul><li>`/*`</li><li>`#`</li><li>`//!`</li><li>`//`</li></ul>,`#`
"<b> In matching patterns, values are ignored with \_.</b><br><ul><li>`.ignore()`</li><li>`an underscore (_)`</li><li>..</li><li>skip</li></ul>",..
<b> Defining a \_ requires a lifetime parameter.</b><br><ul><li>function that ends the lifetime of one of its arguments</li><li>struct that contains a reference to a value</li><li>function with a generic argument</li><li>struct that contains a reference to a boxed value</li></ul>,struct that contains a reference to a value<br><br>[Rust book reference](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-struct-definitions)<br>
"<b> Which example correctly uses std::collections::HashMap's Entry API to populate counts?</b><br><br>```rust<br>use std::collections::HashMap;<br>fn main() {<br>let mut counts = HashMap::new();<br>let text = ""LinkedIn Learning"";<br>for c in text.chars() {<br>// Complete this block<br>}<br>println!(""{:?}"", counts);<br>}<br>```<br>- [ ]<br>```rust<br>for c in text.chars() {<br>if let Some(count) = &mut counts.get(&c) {<br>counts.insert(c, *count + 1);<br>} else {<br>counts.insert(c, 1);<br>};<br>}<br>```<br>- [x]<br>```rust<br>for c in text.chars() {<br>let count = counts.entry(c).or_insert(0);<br>*count += 1;<br>}<br>```<br>- [ ]<br>```rust<br>for c in text.chars() {<br>let count = counts.entry(c);<br>*count += 1;<br>}<br>```<br>- [ ]<br>```rust<br>for c in text.chars() {<br>counts.entry(c).or_insert(0).map(|x| x + 1);<br>}<br>```<br>[reference](https://doc.rust-lang.org/std/collections/hash_map/struct.HashMap.html#method.entry)<br><br><ul></ul>",<ul></ul>
"<b> Which fragment does not incur memory allocations while writing to a ""file"" (represented by a Vec<u</b><br><br>```rust<br>use std::collections::HashMap;<br>fn main() -> Result<(), Box<dyn std::error::Error>> {<br>let mut v = Vec::<u8>::new();<br>let a = ""LinkedIn"";<br>let b = 123;<br>let c = 'ðŸ§€';<br>// replace this line<br>println!(""{:?}"", v);<br>Ok(())<br>}<br>```<br>- [x]<br>```rust<br>write!(&mut v, ""{}{}{}"", a, b, c)?;<br>```<br>- [ ]<br>```rust<br>v.write(a)?;<br>v.write(b)?;<br>v.write(c)?;<br>```<br>- [ ]<br>```rust<br>v.write(a, b, c)?;<br>```<br>- [ ]<br>```rust<br>v.write_all(a.as_bytes())?;<br>v.write_all(&b.to_string().as_bytes())?;<br>c.encode_utf8(&mut v);<br>```<br>1. [Answered in rust user forum](https://users.rust-lang.org/t/formatting-and-writing-to-a-file-without-malloc-or-locks/52295/9)<br>2. [reference](https://doc.rust-lang.org/std/macro.write.html)<br><br><ul></ul>",<ul></ul>
"<b> Does the `main` function compile? If so, why? If not, what do you need to change?</b><br><br>```rust<br>fn main() {<br>let Some(x) = some_option_value;<br>}<br>```<br><br><ul><li>The code does not compile. `let` statements require a refutable pattern. Add `if` before `let`.</li><li>The code compiles. `let` statements sometimes require a refutable pattern.</li><li>The code does not compile. `let` statements requires an irrefutable pattern. Add `if` before `let`.</li><li>The code compiles. `let` do not require a refutable pattern.</li></ul>",The code does not compile. `let` statements requires an irrefutable pattern. Add `if` before `let`.
<b> Which statement about lifetimes is false?</b><br><ul><li>Lifetimes were redundantly specified in previous version of Rust.</li><li>Lifetimes are specified when a struct is holding a reference to a value.</li><li>Lifetimes are specified when certain values must outlive others.</li><li>Lifetimes are always inferred by the compiler.</li></ul>,Lifetimes are always inferred by the compiler.
"<b> When used as a return type, which Rust type plays a similar role to Python's `None`, JavaScript's `null`, or the `void` type in C/C++?</b><br><ul><li>`!`</li><li>`None`</li><li>`Null`</li><li>`()`</li></ul>",`()`
"<b> To convert a `Result` to an `Option`, which method should you use?</b><br><ul><li>`.as_option()`</li><li>`.ok()`</li><li>`.to_option()`</li><li>`.into()`</li></ul>",`.ok()`
"<b> Which statement about the `Clone` and `Copy` traits is false?</b><br><ul><li>`Copy` is enabled for primitive, built-in types.</li><li>Without `Copy`, Rust applies move semantics to a type's access.</li><li>When using `Clone`, copying data is explicit.</li><li>Until a type implements either `Copy` or `Clone`, its internal data cannot be copied.</li></ul>","`Copy` is enabled for primitive, built-in types.<br><br>[ref from stack overflow](https://stackoverflow.com/questions/41413336/do-all-primitive-types-implement-the-copy-trait)<br>"
"<b> Why does this code _not_ compile?</b><br><br>```rust<br>fn returns_closure() -> dyn Fn(i32) -> i32 {<br>|x| x + 1<br>}<br>```<br><br><ul><li>The returned `fn` pointer and value need to be represented by another trait.</li><li>Closures are types, so they cannot be returned directly from a function.</li><li>Closures are types and can be returned only if the concrete trait is implemented.</li><li>Closures are represented by traits, so they cannot be a return type.</li></ul>","Closures are represented by traits, so they cannot be a return type.<br><br>[Rust book reference](https://doc.rust-lang.org/book/ch19-05-advanced-functions-and-closures.html#returning-closures)<br>"
<b> What smart pointer is used to allow multiple ownership of a value in various threads?</b><br><ul><li>`Arc<T>`</li><li>`Box<T>`</li><li>Both `Arc<T>` and `Rc<T>` are multithread safe.</li><li>`Rc<T>`</li></ul>,`Arc<T>`<br><br>[Rust book reference](https://doc.rust-lang.org/book/ch16-03-shared-state.html?highlight=arc%3CT%3E#atomic-reference-counting-with-arct)<br>
<b> Which types are _not_ allowed within an enum variant's body?</b><br><ul><li>zero-sized types</li><li>structs</li><li>trait objects</li><li>floating-point numbers</li></ul>,trait objects<br><br>[Reference](https://doc.rust-lang.org/reference/types/trait-object.html)<br>
<b> Which statement about this code is true?</b><br><br>```rust<br>fn main() {<br>let c = 'z';<br>let heart_eyed_cat = 'ðŸ˜»';<br>}<br>```<br><br><ul><li>Both are character literals.</li><li>`heart_eyed_cat` is an invalid expression.</li><li>`c` is a string literal and `heart_eyed_cat` is a character literal.</li><li>Both are string literals.</li></ul>,Both are character literals.<br><br>[Reference](https://doc.rust-lang.org/std/primitive.char.html)<br>
<b> Your application requires a single copy of some data type T to be held in memory that can be accessed by multiple threads. What is the thread-safe wrapper type?</b><br><ul><li>`Mutex<Arc<T>>`</li><li>`Rc<Mutex<T>>`</li><li>`Arc<Mutex<T>>`</li><li>`Mutex<Rc<T>>`</li></ul>,`Arc<Mutex<T>>`<br><br>[Rust book reference](https://doc.rust-lang.org/book/ch16-03-shared-state.html#atomic-reference-counting-with-arct)<br>
"<b> Which idiom can be used to concatenate the strings `a`, `b`, `c`?</b><br><br>```rust<br>let a = ""a"".to_string();<br>let b = ""b"".to_string();<br>let c = ""c"".to_string();<br>```<br><br><ul><li>`String::from(a,b,c)`</li><li>`format!(""{}{}{}"", a, b, c)`</li><li>`concat(a,b,c)`</li><li>`a + b + c`</li></ul>","`format!(""{}{}{}"", a, b, c)`"
"<b> In this function. what level of access is provided to the variable `a`?</b><br><br>```rust<br>use std::fmt::Debug;<br>fn report<T:Debug>(a: &T) {<br>eprintln!(""info: {:?}"", a);<br>}<br>```<br><br><ul><li>print</li><li>read-only</li><li>read/write</li><li>debug</li></ul>",read-only
<b> Which choice is _not_ valid loop syntax?</b><br><ul><li>`loop`</li><li>`for`</li><li>`while`</li><li>`do`</li></ul>,`do`
"<b> How do you construct a value of `Status` that is initialized to `Waiting`?</b><br><br>```rust<br>enum Status {<br>Waiting,<br>Busy,<br>Error(String),<br>}<br>```<br><br><ul><li>`let s = Enum::new(Status::Waiting);`</li><li>`let s = new Status::Waiting;`</li><li>`let s = Status::Waiting;`</li><li>`let s = Status::new(Waiting);`</li></ul>",`let s = Status::Waiting;`
<b> Which statement about enums is false?</b><br><ul><li>Enums are useful in matching patterns.</li><li>Option is an enum type.</li><li>Enum variants can have different types with associated data.</li><li>the term _enum_ is short for _enummap_</li></ul>,the term _enum_ is short for _enummap_
<b> What does an underscore (\_) indicate when used as pattern?</b><br><ul><li>It matches everything.</li><li>It matches underscores.</li><li>It matches any value that has a length of 1.</li><li>It matches nothing.</li></ul>,It matches everything.
"<b> What is a safe operation on a `std::cell:UnsafeCell<T>`?</b><br><ul><li>A `&mut T` reference is allowed. However it may not cpexists with any other references. and may be created only in single-threaded code.</li><li>`UnsafeCell<T>` provides thread-safety. Therefore, creating `&T` references from multiple threads is safe.</li><li>The only safe operation is the `.get()` method, which returns only a raw pointer.</li><li>Non. `UnsafeCell<T>` only allows code that would otherwise need unsafe blocks to be written in safe code.</li></ul>","The only safe operation is the `.get()` method, which returns only a raw pointer.<br><br>[Reference](https://doc.rust-lang.org/stable/std/cell/struct.UnsafeCell.html)<br>"
"<b> Generics are useful when you **\_**.</b><br><ul><li>need to reduce code duplication by concretizing values and restricting parameters in functions</li><li>need to reduce code duplication by abstracting values further, such as in function parameters</li><li>need a supertrait</li><li>are not sure if you need a specific kind of trait</li></ul>","need to reduce code duplication by abstracting values further, such as in function parameters"
